#include "main.h"

volatile uint16_t adc_val;
volatile uint8_t adc_flag = 0;
uint16_t adc_samples[20];

void ADC_init(void) {
    // Enable GPIOA clock
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // Set PA4 as analog mode
    GPIOA->MODER |= GPIO_MODER_MODE4;

    // Enable the ADC interface clock
    RCC->APB2ENR |= RCC_APB2ENR_ADCEN;

    // Configure the ADC clock source
    RCC->CCIPR &= ~RCC_CCIPR_ADCSEL;   // Clear the ADC clock selection bits
    RCC->CCIPR |= RCC_CCIPR_ADCSEL_0;  // Select HSI16 (16 MHz RC oscillator) as ADC clock

    // ADC configuration
    ADC1->CFGR &= ~ADC_CFGR_RES; // 12-bit resolution
    ADC1->CFGR &= ~ADC_CFGR_ALIGN; // Right alignment
    ADC1->CFGR &= ~ADC_CFGR_CONT; // Disable continuous conversion

    // ADC Sampling Time Configuration for Channel 9
    ADC1->SMPR1 &= ~ADC_SMPR1_SMP9; // Clear previous settings
    ADC1->SMPR1 |= ADC_SMPR1_SMP9_0; // Sampling time: 2.5 ADC clock cycles

    // ADC Regular Channel Configuration
    ADC1->SQR1 &= ~ADC_SQR1_SQ1; // Reset channel
    ADC1->SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_3; // Set channel 9 to rank 1

    // Enable ADC1
    ADC1->CR |= ADC_CR_ADEN;
    while(!(ADC1->ISR & ADC_ISR_ADRDY)); // Wait for ADC ready
}

void ADC1_2_IRQHandler(void) {
    // Check if ADC conversion is complete
    if (ADC1->ISR & ADC_ISR_EOC) {
        adc_val = ADC1->DR;  // Save conversion result
        adc_flag = 1;  // Set flag
    }
}

uint32_t ADC_Read(void) {
    ADC1->CR |= ADC_CR_ADSTART;
    while(adc_flag == 0);  // Wait for ADC conversion to complete
    adc_flag = 0;  // Clear flag
    return adc_val;
}

main(){
	ADC_init();
	    uint16_t min, max;
	    uint32_t avg;

	    while(1) {
	        for (int i = 0; i < 20; i++) {
	            adc_samples[i] = ADC_Read();
	        }
	        process_samples(adc_samples, &min, &max, &avg);

	        // Convert min, max, and avg to calibrated voltage values and send to USART
	        send_to_USART(min);
	        send_to_USART(max);
	        send_to_USART(avg);
	    }
}

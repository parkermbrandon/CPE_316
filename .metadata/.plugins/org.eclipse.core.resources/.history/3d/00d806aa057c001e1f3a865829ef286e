#include "main.h"

void ADC_init(void);
void UART_init();
void UART_print(const char * message);

volatile uint16_t adc_val;
volatile uint8_t adc_flag = 0;
uint16_t adc_samples[20];

void ADC_init(void) {
    // Enable GPIOA clock
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // Set PA4 as analog mode
    GPIOA->MODER |= GPIO_MODER_MODE4;

    // Enable the ADC interface clock
    RCC->AHB2ENR |= RCC_AHB2ENR_ADCEN;

    // Configure the ADC clock source
    RCC->CCIPR &= ~RCC_CCIPR_ADCSEL;   // Clear the ADC clock selection bits
    RCC->CCIPR |= RCC_CCIPR_ADCSEL_0;  // Select HSI16 (16 MHz RC oscillator) as ADC clock

    // ADC configuration
    ADC1->CFGR &= ~ADC_CFGR_RES; // 12-bit resolution
    ADC1->CFGR &= ~ADC_CFGR_ALIGN; // Right alignment
    ADC1->CFGR &= ~ADC_CFGR_CONT; // Disable continuous conversion

    // ADC Sampling Time Configuration for Channel 9
    ADC1->SMPR1 &= ~ADC_SMPR1_SMP9; // Clear previous settings
    ADC1->SMPR1 |= ADC_SMPR1_SMP9_0; // Sampling time: 2.5 ADC clock cycles

    // ADC Regular Channel Configuration
    ADC1->SQR1 &= ~ADC_SQR1_SQ1; // Reset channel
    ADC1->SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_3; // Set channel 9 to rank 1

    // Disable ADC deep power-down mode
    ADC1->CR &= ~ADC_CR_DEEPPWD;

    // Enable ADC internal voltage regulator
    ADC1->CR |= ADC_CR_ADVREGEN;

    // Delay for ADC voltage regulator stabilization (time is dependent on the system clock)
    // Assuming a delay of 10us is sufficient, you can adjust based on your clock settings
    for (volatile uint32_t delay = 0; delay < 640; delay++);  // Assuming 64MHz system clock

    // Start ADC self-calibration
    ADC1->CR |= ADC_CR_ADCAL;

    // Wait for calibration to complete
    while (ADC1->CR & ADC_CR_ADCAL);

    // Enable ADC1
    ADC1->CR |= ADC_CR_ADEN;
    while(!(ADC1->ISR & ADC_ISR_ADRDY)); // Wait for ADC ready
}

// Function to print a string via LPUART1
void UART_print(const char *str) {
    while (*str) {
        // Wait for Transmit Data Register Empty
        while (!(LPUART1->ISR & USART_ISR_TXE));

        // Write data to TDR
        LPUART1->TDR = *str;

        // Wait for Transmission Complete
        while (!(LPUART1->ISR & USART_ISR_TC));

        str++;
    }
}

void UART_init(void){

}

void ADC1_2_IRQHandler(void) {
    // Check if ADC conversion is complete
    if (ADC1->ISR & ADC_ISR_EOC) {
        adc_val = ADC1->DR;  // Save conversion result
        adc_flag = 1;  // Set flag
    }
}

uint32_t ADC_Read(void) {
    ADC1->CR |= ADC_CR_ADSTART;
    while(adc_flag == 0);  // Wait for ADC conversion to complete
    adc_flag = 0;  // Clear flag
    return adc_val;
}

main(){
	ADC_init();
	    uint16_t min, max;
	    uint32_t avg;

	    while(1) {
	        for (int i = 0; i < 20; i++) {
	            adc_samples[i] = ADC_Read();
	        }
	        //process_samples(adc_samples, &min, &max, &avg);

	        // Convert min, max, and avg to calibrated voltage values and send to USART
//	        send_to_USART(min);
//	        send_to_USART(max);
//	        send_to_USART(avg);
	    }
}
